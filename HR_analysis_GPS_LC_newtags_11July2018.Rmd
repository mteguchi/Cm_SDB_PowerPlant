---
title: "R Notebook"
output: html_notebook
---

San Diego Bay Turtle Movement Analysis
Original R Code, JT Froeschke, December 29, 2015
Data modified from previous versions by SE Graham, June 2016, May 2018
Data modified from May 2018 by T EGuchi, July 2018

Filtered data utilize GPS, and Argos LC = 1,2,3
Filtered data do not include points on land
Filtered data only allow for 1 relocation every 4 horus

Purpose of the script is to compute homerange (area) using 
least squares cross-validation including 50% and 95% contours.
An analysis of each turtle and an aggregate pre and post will be computed
h values are chosen based on best judgment and gst behavior  

```{r}
rm(list = ls())
#getwd()
#list.files()

#Section 1: Load libraries and set wd
library(readxl)
library(dplyr)
library(adehabitatHR)
library(readxl)
library(rgdal)
library(leaflet) 
library(ggplot2)

internet <- FALSE
# Minimum number of relocations per individual to be included in HR analysis
min_n <- 50
```

Get some base layer maps here:

```{r}
# just use the 2014 eelgrass data - there are old data files also
SDBay.eelg.2014 <- spTransform(readOGR(dsn = "GISfiles/Features",
                                       layer = "SD_Baywide_Eelgrass_2014_Final",
                                       verbose = F),
                               CRS("+proj=longlat +datum=WGS84"))
SDBay.eelg.2014.df <- broom::tidy(SDBay.eelg.2014)

SDBay.eelg.2008 <- spTransform(readOGR(dsn = "GISfiles/Features",
                                       layer = "SD_Baywide_Eelgrass_2008",
                                       verbose = F),
                               CRS("+proj=longlat +datum=WGS84"))
SDBay.eelg.2008.df <- broom::tidy(SDBay.eelg.2008)

if (internet){
  sdbay.all <- ggmap::get_map(location = c(lon = -117.15,
                                           lat = 32.65),
                       zoom = 12,
                       maptype = "satellite",
                       color = "bw",
                       filename = 'sdbay_all',
                       force = F)
  saveRDS(sdbay.all, file = 'RData/sdbay_all.rds')

  sdbay.south <- ggmap::get_map(location = c(lon = -117.117,
                                             lat = 32.625),
                         zoom = 14,
                         maptype = "satellite",
                         color = "bw",
                         filename = 'sdbay_south',
                         force = F)
  saveRDS(sdbay.south, file = 'RData/sdbay_south.rds')

  sdbay.med <- ggmap::get_map(location = c(lon =  -117.117,
                                           lat = 32.625),
                       zoom = 13,
                       maptype = "satellite",
                       color = "bw",
                       filename = 'sdbay_med',
                       force = F)
  saveRDS(sdbay.med, file = 'RData/sdbay_med.rds')
} else {
  sdbay.all <- readRDS(file = 'RData/sdbay_all.rds')
  sdbay.south <- readRDS(file = 'RData/sdbay_south.rds')
  sdbay.med <- readRDS(file = 'RData/sdbay_med.rds')
}

map.sdbay.zm <- ggmap::ggmap(sdbay.all)

map.sdbay.south <- ggmap::ggmap(sdbay.south)

map.sdbay.med <- ggmap::ggmap(sdbay.med)

# read in the SDB shape file:
SDB.shape <- readOGR(dsn = "GISFiles", layer = "sd_bay")
SDBay <- spTransform(readOGR(dsn = "GISfiles",
                             layer = "sd_bay",
                             verbose = F),
                     CRS("+proj=longlat +datum=WGS84"))
SDBay.df <- broom::tidy(SDBay)

water <- spTransform(readOGR(dsn = "GISFiles", 
                             layer = "water",
                             verbose = F),
                     CRS("+proj=longlat +datum=WGS84"))
water.df <- broom::tidy(water) %>%
  filter(lat < 32.75 & lat > 32.58 & long > -117.25)

tagprj <- readOGR(dsn = "Tag_065_UTMzone11n", 
                  layer = "tag_065_project")
tagproj <- proj4string(tagprj)

# not sure what this part is doing... 
latlong = "+init=epsg:4326"
```

Section 2: read in data

Section 2.1: Pre

```{r}
ID.names <- function(name){
  x <- unlist(strsplit(name, '_'))[1]
  return(x)
}
dname <- "data/files_Apr2018_withNewTags/pre/"
pre.files <- dir(path = dname, 
                 pattern = "_inside_DayNight_4hrs_2018-07-11.csv")

pre.IDs <- unlist(lapply(pre.files, FUN = ID.names))

pre.all <- do.call(rbind, 
                   lapply(pre.files,
                          FUN = function(x) read.csv(paste0(dname, x)))) %>%
  mutate(ID.f = as.factor(ArgosID)) %>%
  filter(include == 1)


write.csv(pre.all, paste0(dname, "Pre_GPS_LC_all.csv"), 
          row.names=FALSE)

```

Plot the data points to see what they look like:

```{r}
map.pre <- map.sdbay.zm + 
  geom_polygon(data = SDBay.df,
               aes(x = long, y = lat)) +
               #fill = "blue",alpha = 0.6) + 
  geom_polygon(data = SDBay.eelg.2008.df,
               aes(x = long,
                   y = lat,
                   group = group),
               fill = "green",
               alpha = 0.5) +
  geom_point(data = pre.all,
             aes(x = Lon1, y = Lat1, color = ID.f),
             alpha = 0.5)+ 
  # geom_polygon(data = water.df,
  #              aes(x = long,
  #                  y = lat,
  #                  group = group),
  #              fill = "blue",
  #              alpha = 0.2) +

  #coord_map() + 
  #labs(color = 'ARGOS ID') + 
  xlab('Longitude') + ylab('Latitude') + 
  theme(legend.title = element_text(size = 10, hjust = 0.5),
        legend.text = element_text(size = 8, vjust = 0),
        legend.position = "none")

plot(map.pre)
```



Do the same for post 

```{r}
dname <- "data/files_Apr2018_withNewTags/post/"
post.files <- dir(path = dname, 
                 pattern = "_inside_DayNight_4hrs_2018-07-11.csv")

post.IDs <- unlist(lapply(post.files, FUN = ID.names))

post.all <- do.call(rbind, 
                   lapply(post.files,
                          FUN = function(x) read.csv(paste0(dname, x)))) %>%
  mutate(ID.f = as.factor(ArgosID)) %>%
  filter(include == 1)

map.post <- map.sdbay.zm + 
   geom_polygon(data = SDBay.df,
               aes(x = long, y = lat)) +
               #fill = "blue",
               #alpha = 0.6) + 
  geom_polygon(data = SDBay.eelg.2014.df,
               aes(x = long,
                   y = lat,
                   group = group),
               fill = "green",
               alpha = 0.6) +
  geom_point(data = post.all,
             aes(x = Lon1, y = Lat1, color = ID.f),
             alpha = 0.5)+ 
  labs(color = 'ARGOS ID') + 
  xlab('Longitude') + ylab('Latitude') + 
  theme(#legend.title = element_text(size = 10, hjust = 0.5),
        #legend.text = element_text(size = 8, vjust = 0),
        #legend.position = c(0.2, 0.5),
        legend.position = "none")

plot(map.post)
```

And probably we should inlude the new files into "post". Also, take out the one track that goes out the bay - north of 32.66N
```{r}
dname <- "data/files_Apr2018_withNewTags/new/"
new.files <- dir(path = dname, 
                 pattern = "_inside_DayNight_4hrs_2018-07-11.csv")

new.IDs <- unlist(lapply(new.files, FUN = ID.names))

new.all <- do.call(rbind, 
                   lapply(new.files,
                          FUN = function(x) read.csv(paste0(dname, x)))) %>%
   mutate(ID.f = as.factor(ArgosID)) %>%
 filter(include == 1)

post.all <- rbind(post.all, new.all) %>%
  filter(Lat1 < 32.66)

write.csv(post.all, paste0(dname, "Post_GPS_LC_all.csv"), 
          row.names=FALSE)

map.post <- map.sdbay.zm + 
  geom_polygon(data = SDBay.df,
               aes(x = long, y = lat)) + 
               #fill = "blue",
               #alpha = 0.6) + 
  geom_polygon(data = SDBay.eelg.2014.df,
               aes(x = long,
                   y = lat,
                   group = group),
               fill = "green",
               alpha = 0.6) +geom_point(data = post.all,
             aes(x = Lon1, y = Lat1, color = ID.f),
             alpha = 0.5)+ 
  labs(color = 'ARGOS ID') + 
  xlab('Longitude') + ylab('Latitude') + 
  theme(#legend.title = element_text(size = 10, hjust = 0.5),
        #legend.text = element_text(size = 8, vjust = 0),
        #legend.position = c(0.2, 0.5),
    legend.position = "none")

plot(map.post)
```

We have a lot more individuals from the post period than the pre, so we need to do something about that... especially for computing HRs. 


Section 3: Compute HRs
Get coordinates as a dataframe and make a spatial object
```{r}
# when trying to compute HR for each individual, some don't have enough data
# extract those with at least 100 data points:

pre.all %>% count(by = ArgosID) %>%
  filter(n > (min_n - 1)) %>%
  #dplyr::select(by) %>%
  rename(ArgosID = by) -> ID.pre.min_n

pre.selected <- right_join(pre.all, ID.pre.min_n, by = "ArgosID")

# treat all individuals as a group without ID - use all of them to make one HR
pre.all.coords <- data.frame(x=pre.selected$Lon1, 
                             y=pre.selected$Lat1)

coordinates(pre.all.coords) <- ~ x + y
proj4string(pre.all.coords) <- CRS(latlong)
pre.all.utm <- spTransform(pre.all.coords, tagproj)

#class(pre.all.coords)
#plot(pre.all.coords, axes=TRUE) ## sanity check

# use those with at least 100:
# treat all individuals as a group without ID - use all of them
pre.byID.coords <- data.frame(x = pre.selected$Lon1, 
                              y = pre.selected$Lat1,
                              ID = as.factor(pre.selected$ArgosID))

coordinates(pre.byID.coords) <- ~ x + y
proj4string(pre.byID.coords) <- CRS(latlong)
pre.byID.utm <- spTransform(pre.byID.coords, tagproj)
```

Do the same with post dataset - choose those with at least min_n data points. 

```{r}
post.all %>% count(by = ArgosID) %>%
  filter(n > (min_n - 1)) %>%
  #dplyr::select(by) %>%
  rename(ArgosID = by) -> ID.post.min_n

# because there are more post tracks than pre tracks, 5 vs. 11(?), it may make sense to 
# randomly draw 5 at a time and look at how computed home range changes. You'd think 
# more turtles means larger home range? 

post.selected <- right_join(post.all, ID.post.min_n, by = "ArgosID")

# remove individuals with small sample size:
post.all.coords <- data.frame(x=post.selected$Lon1, 
                              y=post.selected$Lat1)
coordinates(post.all.coords) <- ~ x + y
proj4string(post.all.coords) <- CRS(latlong)
post.all.utm <- spTransform(post.all.coords, tagproj)
#plot(post.all.utm, axes=TRUE) ## sanity check

post.byID.coords <- data.frame(x=post.selected$Lon1, 
                                   y=post.selected$Lat1,
                                   ID = as.factor(post.selected$ArgosID))
coordinates(post.byID.coords) <- ~ x + y
proj4string(post.byID.coords) <- CRS(latlong)
post.byID.utm <- spTransform(post.byID.coords, tagproj)

```

Then the home range analysis starts here:

```{r}
## Section 3.1.2
##Visually optimized hlim = c(0.565,1.5), grid=300
# grid values from 50 to 300 don't change the outcome;
# extent values from 1 to 200 don't change the outcome either

#LSCV estimated band width is too small and home range becomes fragmented
# so, I increased it to 100
h <- 100
pre.all.kd <- kernelUD(pre.all.utm, 
                       h = h,  
                       hlim = c(0.03, 1.5), 
                       grid = 300,
                       extent = 1,
                       kern = "bivnorm")

#plotLSCV(pre.all.kd)
pre.Area.all <- kernel.area(pre.all.kd, 
                            percent = c(50, 95),
                            unin = c("m"),
                            unout = c("km2"), 
                            standardize = FALSE)
#pre.Area.all
# we should probably use the same bandwidth as the whole?
pre.byID.kd <- kernelUD(pre.byID.utm, 
                            h = pre.all.kd@h$h ,  
                            hlim = c(0.03, 1.5), 
                            grid = 300,
                            extent = 1,
                            kern = "bivnorm")

#plotLSCV(pre.byID.kd)
pre.Area.byID <- kernel.area(pre.byID.kd, 
                             percent = c(50, 95),
                             unin = c("m"),
                             unout = c("km2"), 
                             standardize = FALSE)
#pre.Area.selected

pre.bw <- pre.all.kd@h$h ##bandwidth estimate
pre.Area.50 <- round(pre.Area.all["50"],2)
pre.Area.95 <- round(pre.Area.all["95"],2)

pre.ver.50 <- getverticeshr(pre.all.kd, 50)
pre.ver.95 <- getverticeshr(pre.all.kd, 95)

plot(pre.ver.50, axes = TRUE)
plot(pre.ver.95, axes = TRUE)
#points(pre.all.utm, col="blue")

```
Make a plot:
```{r}

pre.ver.50.df <- broom::tidy(spTransform(pre.ver.50, CRS("+proj=longlat")))
pre.ver.95.df <- broom::tidy(spTransform(pre.ver.95, CRS("+proj=longlat")))

map.pre.HR <- map.sdbay.zm + 
  geom_polygon(data = SDBay.df,
               aes(x = long, y = lat)) +
               #fill = "blue",alpha = 0.6) + 
  geom_polygon(data = SDBay.eelg.2008.df,
               aes(x = long,
                   y = lat,
                   group = group),
               fill = "green",
               alpha = 0.5) +
  geom_polygon(data = pre.ver.95.df,
               aes(x = long, y = lat,
                   group = group),
               fill = "cornsilk",
               alpha = 0.6) + 
  geom_polygon(data = pre.ver.50.df,
               aes(x = long, y = lat,
                   group = group),
               fill = "red3",
               alpha = 0.6) + 
  geom_point(data = pre.all,
             aes(x = Lon1, y = Lat1),
             alpha = 0.5,
             size = 0.2)+ 
  # geom_polygon(data = water.df,
  #              aes(x = long,
  #                  y = lat,
  #                  group = group),
  #              fill = "blue",
  #              alpha = 0.2) +

  #coord_map() + 
  #labs(color = 'ARGOS ID') + 
  xlab('Longitude') + ylab('Latitude') + 
  theme(#legend.title = element_text(size = 10, hjust = 0.5),
        #legend.text = element_text(size = 8, vjust = 0),
        legend.position = "none")


#plot(map.pre.HR)
```

Do the same for the post data - here we need to look at subsampling individuals. 


```{r}
## Section 3.1.2
##Visually optimized hlim = c(0.565,1.5), grid=300

post.all.kd <- kernelUD(post.all.utm, 
                        h = h,  
                        hlim = c(0.01, 1.5), 
                        grid = 300,
                        extent = 1,
                        kern = "bivnorm")

#plotLSCV(post.all.kd)
post.Area.all <- kernel.area(post.all.kd, 
                             percent = c(50, 95),
                             unin = c("m"),
                             unout = c("km2"), 
                             standardize = FALSE)
post.Area.all

post.byID.kd <- kernelUD(post.byID.utm, 
                         h = h,  
                         hlim = c(0.03, 1.5), 
                         grid = 300,
                         extent = 1,
                         kern = "bivnorm")

#plotLSCV(post.selected.kd)
post.Area.byID <- kernel.area(post.byID.kd, 
                              percent = c(50, 95),
                              unin = c("m"),
                              unout = c("km2"), 
                              standardize = FALSE)
post.Area.byID

post.bw <- post.all.kd@h$h ##bandwidth estimate
post.Area.50 <- round(post.Area.all["50"],2)
post.Area.95 <- round(post.Area.all["95"],2)

post.ver.50 <- getverticeshr(post.all.kd, 50)
post.ver.95 <- getverticeshr(post.all.kd, 95)

plot(post.ver.50, axes = TRUE)
plot(post.ver.95, axes = TRUE)
#points(pre.all.utm, col="blue")
```


Make a plot:
```{r}

post.ver.50.df <- broom::tidy(spTransform(post.ver.50, CRS("+proj=longlat")))
post.ver.95.df <- broom::tidy(spTransform(post.ver.95, CRS("+proj=longlat")))

map.post.HR <- map.sdbay.zm + 
  geom_polygon(data = SDBay.df,
               aes(x = long, y = lat)) +
               #fill = "blue",alpha = 0.6) + 
  geom_polygon(data = SDBay.eelg.2014.df,
               aes(x = long,
                   y = lat,
                   group = group),
               fill = "green",
               alpha = 0.5) +
  geom_polygon(data = post.ver.95.df,
               aes(x = long, y = lat,
                   group = group),
               fill = "cornsilk",
               alpha = 0.6) + 
  geom_polygon(data = post.ver.50.df,
               aes(x = long, y = lat, 
                   group = group),
               fill = "red3",
               alpha = 0.6) + 
  geom_point(data = post.all,
             aes(x = Lon1, y = Lat1),
             alpha = 0.5,
             size = 0.2)+ 
  # geom_polygon(data = water.df,
  #              aes(x = long,
  #                  y = lat,
  #                  group = group),
  #              fill = "blue",
  #              alpha = 0.2) +

  #coord_map() + 
  #labs(color = 'ARGOS ID') + 
  xlab('Longitude') + ylab('Latitude') + 
  theme(#legend.title = element_text(size = 10, hjust = 0.5),
        #legend.text = element_text(size = 8, vjust = 0),
        legend.position = "none")

ggsave(filename = paste0("figures/HR_pre_h100_", Sys.Date(), ".png"),
       plot = map.pre.HR,
       dpi = 600,
       device = "png")

ggsave(filename = paste0("figures/HR_post_h100_", Sys.Date(), ".png"),
       plot = map.post.HR,
       dpi = 600,
       device = "png")
#plot(map.post.HR)
```