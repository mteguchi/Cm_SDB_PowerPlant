---
title: "Extract statistics for ms revision"
output: html_notebook
---

This document extracts necessary statistics for the revision of the manuscript

```{r}
rm(list = ls())

library(dplyr)
library(adehabitatHR)
library(rgdal)
library(leaflet) 
library(ggplot2)
library(lubridate)
library(tidyverse)
library(ggridges)
library(lme4)
library(mgcv)
library(sf)

source("HR_analysis_fcns.R")

save.fig <- F

# Minimum number of relocations per individual to be included in HR analysis
min_n <- 50
#N.end <- 32.69   # approx Coronado bridge
N.end <- 32.66 # changed from 32.69 because 152314 had a gap in data points between ~32.65 and ~32.66 - seems like there was a different behavior south and north of 32.66

map.west.east <- c(-117.16, -117.09)
map.north.south <- c(32.595, 32.665)

pre.95.fill <- "lightgoldenrod2"
pre.95.color <- "lightgoldenrod3"
pre.50.fill <- "goldenrod2"
pre.50.color <- "goldenrod3"
water.color <- "lavender"

post.95.color <- "mediumpurple3"
post.95.fill <- "mediumpurple2"
post.50.color <- "purple3"
post.50.fill <- "purple2"

background.color <- "darkgray" #"grey25" #
eelgrass.color <- "mediumseagreen"

grid <- 1000
extent <- 1

#source("HR_analysis_fcns.R")
tagprj <- readOGR(dsn = "Tag_065_UTMzone11n", 
                  layer = "tag_065_project")
tagproj <- proj4string(tagprj)

```

Then, pull out statistics in the order that they are used in the manuscript. 

To find out the proportion of accepted locations for GPS, we need to pull out files with _inout.csv extensions. 

First, day and night are combined. pre.n and post.n contain four columns:

1. ArgosID

2. the number of data points after deciding inside or outside SDB (all)

3. the number of data points excluding those with residual values > 35.0, outside SDB, and north of N.end (32.66 as of 16 Dec 2019) (filtered)

4. the number of data points after splitting into 4-hr blocks and taking one from each block

```{r}
pre.all <- read.csv("data/Pre_GPS_all.csv")
post.all <- read.csv("data/Post_GPS_all.csv")

pre.IDs <- unique(pre.all$ArgosID)
post.IDs <- unique(post.all$ArgosID)
all.IDs <- c(pre.IDs, post.IDs)

post.n <- pre.n <- data.frame(ArgosID = NA, all = NA, filtered = NA, final = NA)
k <- 1
for (k in 1:length(pre.IDs)){
  filename <- paste0("data/files_Oct2019_withNewTags/pre/", 
                     pre.IDs[k], "_inout.csv")
  filename1 <- paste0("data/files_Oct2019_withNewTags/pre/", 
                      pre.IDs[k], "_inside_DayNight_4hrs_GPS.csv")
  dat.all <- read.csv(file = filename) %>% filter(Message_Type == "GPS")
  dat.all %>% filter(Lat1 < N.end) %>% 
    filter(Residual <= 35) %>%
    filter(inside == 1) -> dat.filtered
  dat.final <- read.csv(file = filename1)

  pre.n[k, ] <- c(pre.IDs[k], nrow(dat.all), nrow(dat.filtered), nrow(dat.final))

}

pre.n$pre0post1 <- 0

k <- 1
for (k in 1:length(post.IDs)){
  # these are "new" tags
  if (post.IDs[k] <= 152323 & post.IDs[k] >= 151375 ){
    filename <- paste0("data/files_Oct2019_withNewTags/new/", 
                       post.IDs[k], "_inout.csv")
    filename1 <- paste0("data/files_Oct2019_withNewTags/new/", 
                        post.IDs[k], "_inside_DayNight_4hrs_GPS.csv")
    
  } else {
    filename <- paste0("data/files_Oct2019_withNewTags/post/", 
                       post.IDs[k], "_inout.csv")
    filename1 <- paste0("data/files_Oct2019_withNewTags/post/", 
                        post.IDs[k], "_inside_DayNight_4hrs_GPS.csv")
    
  }
  
  dat.all <- read.csv(file = filename) %>% filter(Message_Type == "GPS")
  dat.all %>% filter(Lat1 < N.end) %>% 
    filter(Residual <= 35) %>%
    filter(inside == 1) -> dat.filtered
  
  dat.final <- read.csv(file = filename1)
  
  post.n[k, ] <- c(post.IDs[k], nrow(dat.all), nrow(dat.filtered), nrow(dat.final))
  
}

post.n$pre0post1 <- 1

all.n <- rbind(pre.n, post.n) %>%
  mutate(prop.filtered = filtered/all,
         prop.used = final/all)

all.prop <- sum(all.n$filtered)/sum(all.n$all)

min.prop <- min(all.n$prop.filtered)

used.prop <- sum(all.n$final)/sum(all.n$all)
min.used.prop <- min(all.n$prop.used)

# we want at least 50 data points.
all.n %>% filter(final > 49) -> used.n

lost.pre <- nrow(all.n[all.n$pre0post1 == 0,]) - nrow(used.n[used.n$pre0post1 == 0,])
lost.post <- nrow(all.n[all.n$pre0post1 == 1,]) - nrow(used.n[used.n$pre0post1 == 1,])


```

Combine these with the HR analyses output to make one dataframe. All these files were created in HR_analysis_GPS_LC_newtags_2019-10-31.Rmd. Because we are not interested in individual differences, especially with the small sample sizes for some individuals, we don't split data for each individual into day and night. But, just to show how bad this gets here is summary.

```{r}
pre.UD.byID <- readRDS("RData/pre_GPS_UD_byID.rds")
pre.UD.day.byID <- readRDS("RData/pre_GPS_UD_day_byID.rds") 
pre.UD.day.byID$area %>%  
  transmute(area.50.day = area.50,
            area.75.day = area.75,
            area.95.day = area.95,
            ArgosID = ID) -> pre.UD.day.area.byID

pre.UD.night.byID <- readRDS("RData/pre_GPS_UD_night_byID.rds")
pre.UD.night.byID$area %>%  
  transmute(area.50.night = area.50,
            area.75.night = area.75,
            area.95.night = area.95,
            ArgosID = ID) -> pre.UD.night.area.byID


post.UD.byID <- readRDS("RData/post_GPS_UD_byID.rds")
post.UD.day.byID <- readRDS("RData/post_GPS_UD_day_byID.rds")
post.UD.day.byID$area %>%  
  transmute(area.50.day = area.50,
            area.75.day = area.75,
            area.95.day = area.95,
            ArgosID = ID) -> post.UD.day.area.byID

post.UD.night.byID <- readRDS("RData/post_GPS_UD_night_byID.rds")
post.UD.night.byID$area %>%  
  transmute(area.50.night = area.50,
            area.75.night = area.75,
            area.95.night = area.95,
            ArgosID = ID) -> post.UD.night.area.byID

UD.area.day <- rbind(pre.UD.day.area.byID, post.UD.day.area.byID)
UD.area.night <- rbind(pre.UD.night.area.byID, post.UD.night.area.byID)

UD.area.byID <- rbind(pre.UD.byID$area, post.UD.byID$area) %>%
  mutate(ArgosID = ID) %>% 
  dplyr::select(-ID)

used.n %>% left_join(UD.area.byID, by = "ArgosID") %>% 
  left_join(UD.area.day, by = "ArgosID") %>% 
  left_join(UD.area.night, by = "ArgosID") -> used.n.byID

```

UDs for day+night, day, and night periods using all individuals (created in HR_analysis_GPS_LC_newtags_2019-10-31.Rmd)

```{r}
pre.UD <- readRDS("RData/pre_GPS_UD.rds")
pre.UD.day <- readRDS("RData/pre_GPS_UD_day.rds")
pre.UD.night <- readRDS("RData/pre_GPS_UD_night.rds")

post.UD <- readRDS("RData/post_GPS_UD.rds")
post.UD.day <- readRDS("RData/post_GPS_UD_day.rds")
post.UD.night <- readRDS("RData/post_GPS_UD_night.rds")

```


Determining the sample size necessary to approximate the observed post-period.  
```{r}
post.summary <- read.csv("data/post_sample_summary.csv")
ID.post.min_n <- filter(post.summary,
                       n.relocations.all > (min_n - 1))

pre.summary <- read.csv("data/pre_sample_summary.csv")
ID.pre.min_n <- filter(pre.summary,
                       n.relocations.all > (min_n - 1))

#h.multiplier <-  seq(from = 0.1, to = 0.95, by = 0.05) 
# This loop takes a long time... It was run once already so start from 
# where it was left off. .RData file needs to be loaded to figure out
# how far along the first attempt was. 

# select randomized results 
file.names <- list.files(path = "RData/", pattern = "areas_combos_n")
file.names <- file.names[grep(pattern = "2019-12-17", file.names)]

# initialize empty lists for collecting info
area50.list <- area95.list <- vector(mode = "list", length = length(file.names))
p.d50.list <- p.d95.list <- vector(mode = "list", length = length(file.names))
dif.50.list <- dif.95.list <- vector(mode = "list", length = length(file.names))
Fn.50.0 <- Fn.95.0 <- vector(mode = "numeric", length = length(file.names))

min.k <- nrow(filter(used.n, pre0post1 == 0)) - 1 #3
# file.names are not listed from 4 to 12, so results need to be placed in the 
# right spot 
for (k in 1:length(file.names)){
  # find the sample size for this file:
  n.txt <- unlist(strsplit(strsplit(strsplit(file.names[k], 
                                             split = "areas_combos_")[[1]][2],
                                    split = "_2019-12-17")[[1]][1], 
                           split = "n"))[2]
  
  areas.combos <- readRDS(file = paste0("Rdata/", file.names[k]))
  
  area50.list[[as.numeric(n.txt) - min.k]] <- data.frame(area50 = areas.combos$area50,
                                                     n = as.numeric(n.txt))
  area95.list[[as.numeric(n.txt) - min.k]] <- data.frame(area95 = areas.combos$area95,
                                                     n = as.numeric(n.txt))
  
  dif.50.list[[as.numeric(n.txt) - min.k]] <- data.frame(dif = areas.combos$area50 - pre.UD$HR$area.50)
  dif.95.list[[as.numeric(n.txt) - min.k]] <- data.frame(dif = areas.combos$area95 - pre.UD$HR$area.95)
  
  p.d50.list[[as.numeric(n.txt) - min.k]] <- ggplot(data = dif.50.list[[as.numeric(n.txt) - min.k]]) + 
    geom_histogram(aes(x = dif), binwidth = 0.1) +
    labs(title = paste0("n = ", n.txt), 
         x = "Difference in area (50% UD)", y = "Count")
  
  # find the ecdf of the differences
  Fn.50 <- ecdf(dif.50.list[[as.numeric(n.txt) - min.k]]$dif)
  
  # compute the probability at 0:
  Fn.50.0[as.numeric(n.txt) - min.k] <- Fn.50(0)
  
  #plot(hist.dif.50)
  
  p.d95.list[[as.numeric(n.txt) - min.k]] <- ggplot(data = dif.95.list[[as.numeric(n.txt) - min.k]]) + 
    geom_histogram(aes(x = dif), binwidth = 0.15) +
    labs(title = paste0("n = ", n.txt), 
         x = "Difference in area (95% UD)", y = "Count")
  
  # find the ecdf of the differences
  Fn.95 <- ecdf(dif.95.list[[as.numeric(n.txt) - min.k]]$dif)
  
  # compute the probability at 0:
  Fn.95.0[as.numeric(n.txt) - min.k] <- Fn.95(0)
  
}

```


Make plots to see how the areas changed with sample sizes

```{r}
area50.df <- do.call(rbind, area50.list) %>% 
  mutate(f.n = as.factor(n))

area50.means <- area50.df %>% 
  group_by(f.n) %>% 
  summarize(mean.50 = mean(area50),
            median.50 = median(area50),
            n = first(n)) 

area95.df <- do.call(rbind, area95.list) %>% 
  mutate(f.n = as.factor(n))

area95.means <- area95.df %>% 
  group_by(f.n) %>% 
  summarize(mean.95 = mean(area95),
            median.95 = median(area95),
            n = first(n)) 

pre.df <- data.frame(n = c(nrow(filter(used.n, pre0post1 == 0)), 
                           nrow(filter(used.n, pre0post1 == 0))), 
                     areas = c(pre.UD$HR$area.50, pre.UD$HR$area.95))

post.df <- data.frame(n = c(nrow(filter(used.n, pre0post1 == 1)), 
                            nrow(filter(used.n, pre0post1 == 1))), 
                     areas = c(post.UD$HR$area.50, post.UD$HR$area.95))
 
p.dif.dist <- ggplot() + 
  geom_point(data = area50.df,
             aes(x = n, y = area50)) + 
  geom_point(data = area50.means,
             aes(x = n, 
                 y = mean.50),
             size = 4.5,
             shape = 15) + 
  geom_point(data = area95.df,
             aes(x = n, y = area95)) + 
  geom_point(data = area95.means,
             aes(x = n, 
                 y = mean.95),
             size = 4.5,
             shape = 15) + 
  geom_point(data = pre.df,
             aes(x = n, y = areas),
             color = "green",
             size = 3.5) + 
  geom_hline(yintercept = post.UD$HR$area.50,
             size = 1.5, color = "blue",
             linetype = 2) + 
  geom_hline(yintercept = post.UD$HR$area.95,
             size = 1.5, color = "blue",
             linetype = 2) + 
  scale_x_continuous(breaks = c(min(area95.df$n):max(area95.df$n)),
                     limits = c((min(area95.df$n) - 0.2), (max(area95.df$n) + 0.2))) +
  labs(x = "Number of individuals",
       y = bquote('Estimated UDs (' *km^2*')'))
  
if (save.fig)
  ggsave(filename = paste0("figures/preVsPost_effect_n_", Sys.Date(), ".png"),
         plot = p.dif.dist,
         device = "png",
         dpi = 600)

print(p.dif.dist)
```

This plot shows that (1) the mean 50% UDs did not change from n = 4 to n = 12 and (2) 95% UDs require 11 or more individuals to be a good estimate. The observed pre-period UDs were significantly less than the post-period. 

Look at the difference between n = 4 and n = 12
```{r}
# mean of all n = 4 samples
area50.df %>% filter(n == 4) %>% summarise(mean(area50))

# min and max of n = 12 samples
area50.df %>% filter(n == 12) %>% summarise(min(area50), max(area50))

```


Another way to look at the distributions - ridge plots. 

```{r}

ggplot(data = area50.df) + 
  geom_density_ridges2(aes(x = area50, y = f.n), 
                       scale = 2,
                       fill = "springgreen2") + 
  geom_vline(xintercept = post.UD$HR$area.50,
             size = 1.5, color = "black",
             linetype = 2) + 
  labs(x = "50% UD", y = "Number of individuals")

```

```{r}

ggplot(data = area95.df) + 
  geom_density_ridges2(aes(x = area95, y = f.n), 
                       scale = 2,
                       fill = "springgreen2") + 
  geom_vline(xintercept = post.UD$HR$area.95,
             size = 1.5, color = "black",
             linetype = 2) + 
  labs(x = "95% UD", y = "Number of individuals")

```

Look at the differences between pre and post periods using 50% UDs.

```{r}
# n = 4 is the first list item.
p.d50.n4 <- ggplot(data = dif.50.list[[1]]) + 
    geom_histogram(aes(x = dif), binwidth = 0.1,
                   fill = "gray",
                   col = "black") +
    labs(x = "Difference in area (50% UD)", y = "Count")

if (save.fig)
ggsave(filename = paste0("figures/preVsPost_n4_", Sys.Date(), ".png"),
       plot = p.d50.n4,
       device = "png",
       dpi = 600)


print(p.d50.n4)

p.gt0 <- sum(dif.50.list[[1]]$dif > 0)/length(dif.50.list[[1]]$dif)
```

Now that we know the stability of the core use area with respect to the sample sizes, we compute them extracting the land space.  (this was already done in HR_analysis_GPS_LC_newtags_2019-10-31.Rmd)

Now, I need to look at the effects of various things on the HR sizes.  

The first comparison is the main one; pre vs. post, where using day and night data together.  I use only GPS data first. In this case, no mixed-effecs model is necessary. 


```{r}

dat.table <- read.csv(file = "data/IDvsUDs.csv") 

dat.table %>% 
  dplyr::select(ArgosID, n.days.GPS, n.relocations.all.GPS, 
                n.day.all.GPS, n.night.all.GPS,
                Sex, CCL_cm, 
                period, area.50.all.GPS,
                area.50.day.GPS,
                area.50.night.GPS) %>%
  mutate(period01 = ifelse(period == "pre", 0, 1)) %>% #-> table.area.50.GPS #%>%
  na.omit() -> table.area.50.GPS

lm.fit.all.50 <- lm(formula = area.50.all.GPS ~ period01 + CCL_cm + n.days.GPS + n.relocations.all.GPS,
                    data = table.area.50.GPS)

summary(lm.fit.all.50)
```

The model indicates no significant effects of the period, even though the coefficient is positive, indicating the increase in UD50. This tells us that looking at the individual level, no increase in UDs but as a whole, they increased their spatial use within the bay.  

Second, I use day and night data as separate but drop the combined data.  To account for individuals, they are treated as random effects. There are only 7 individuals available for this analysis.  Just because of this small sample issue, I remove CCL from the list of variables. 

```{r}
dat.table %>%
  dplyr::select(ArgosID, n.days.GPS, n.relocations.all.GPS, 
                n.day.all.GPS, n.night.all.GPS,
                Sex, CCL_cm, 
                period, area.50.night.GPS, area.50.day.GPS) %>%
  mutate(period01 = ifelse(period == "pre", 0, 1)) %>% #-> area.50.day.night.GPS #%>%
  na.omit() -> area.50.day.night.GPS 

area.50.day.night.GPS.long <- gather(area.50.day.night.GPS,
                                     day_night, 
                                     area, 
                                     area.50.night.GPS, 
                                     area.50.day.GPS) %>%
  mutate(day1night2 = ifelse(day_night == "area.50.day.GPS", 1, 2))

# adding period results in singular error
lmm.fit.all.50 <- lmer(formula = area ~ day1night2 +  (1|ArgosID),
                      data = area.50.day.night.GPS.long)

summary(lmm.fit.all.50)
```

UD50s are smaller during the night than the day.   

How about the 95% UDs?

```{r}
dat.table %>% 
  dplyr::select(ArgosID, n.days.GPS, n.relocations.all.GPS, 
                n.day.all.GPS, n.night.all.GPS,
                Sex, CCL_cm, 
                period, area.95.all.GPS) %>%
  mutate(period01 = ifelse(period == "pre", 0, 1)) %>%
  na.omit() -> table.area.95.GPS

lm.fit.all.95 <- lm(formula = area.95.all.GPS ~ period01 + CCL_cm + n.days.GPS + n.relocations.all.GPS,
                    data = table.area.95.GPS)

summary(lm.fit.all.95)


```

Longer data series result in larger 95% UDs, smaller turtles have larger UDs, but not significant effect of pre vs. post. 

Also, random effects model for 95% UDs.

```{r}

dat.table %>%
  dplyr::select(ArgosID, n.days.GPS, n.relocations.all.GPS, n.day.all.GPS, n.night.all.GPS,
         Sex, CCL_cm, 
         period, area.95.night.GPS, area.95.day.GPS) %>%
  mutate(period01 = ifelse(period == "pre", 0, 1)) %>%
  na.omit() -> area.95.day.night.GPS

area.95.day.night.GPS.long <- gather(area.95.day.night.GPS,
                                     day_night, area, 
                                     area.95.night.GPS, area.95.day.GPS) %>%
  mutate(day1night2 = ifelse(day_night == "area.95.day.GPS", 1, 2))

lmm.fit.all.95 <- lmer(formula = area ~ day1night2 + (1|ArgosID),
                      data = area.95.day.night.GPS.long)

summary(lmm.fit.all.95)

```

Nothing really comes out as significant effects because of large uncertainty.  Using individual-based UDs is difficult because of the small sample sizes.  


Look at the difference between day and night
```{r}
area.50.day.night.GPS %>% 
  mutate(dif.day.night = area.50.day.GPS - area.50.night.GPS,
         period01 = ifelse(period == "pre", 0, 1)) -> dif.area.50.day.night.GPS

lm.fit.dif.50 <- lm(formula = dif.day.night ~ period01 + CCL_cm,
                    data = dif.area.50.day.night.GPS)

summary(lm.fit.dif.50)

```


This is going down the rabbit hole... we didn't care so much about at the individual level - we wanted to see how green turtles in SDB as a whole changed their movements/behavior before and after the power plant closure. So, let's focus on that and we already have results!

I think adding Argos data help this issue... To justify, we need to look at how adding Argos locations to GPS data doesn't change the results.

OR DO WE NEED TO DO THAT MUCH... 

Find overlap with eelgrass
```{r}
SDBay <- readOGR(dsn = "GISfiles",
                 layer = "sd_bay",
                 verbose = FALSE)

# create a study area box for the south bay.
p <- Polygon(coords = matrix(c(-117.16,32.66,  
                               -117.09,32.66, 
                               -117.09,32.60, 
                               -117.16,32.60, 
                               -117.16, 32.66),
                             nrow = 5,
                             byrow = T))

south.bay.box <- SpatialPolygons(list(Polygons(list(p), 1)),
                                 proj4string = CRS("+proj=longlat +datum=WGS84"))

SDBay.latlon <- spTransform(SDBay,
                            CRS = CRS("+proj=longlat +datum=WGS84")) 

#SDBay.south.latlon <- rgeos::gIntersection(south.bay.box, SDBay.latlon)
SDBay.latlon.df <- broom::tidy(SDBay.latlon)

eelg.2008.UTM <- readOGR(dsn = "GISfiles/Features",
                         layer = "SD_Baywide_Eelgrass_2008",
                         verbose = F)

eelg.2008.latlon <- spTransform(eelg.2008.UTM,
                                CRS = CRS("+proj=longlat +datum=WGS84"))

eelg.2008.latlon.df <- broom::tidy(eelg.2008.latlon)

# find the south bay eelgrass
eelg.2008.latlon.south <- rgeos::gIntersection(south.bay.box, eelg.2008.latlon)

# recalulate areas of each polygon to make sure they are "correct." 
eelg.2008.all.areas <- lapply(eelg.2008.latlon.south@polygons[[1]]@Polygons,
                    FUN = function(x){
                      areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                        slot(x, "ringDir")
                    } )

for (k in 1:length(eelg.2008.all.areas)){
  slot(eelg.2008.latlon.south@polygons[[1]]@Polygons[[k]], "area") <- eelg.2008.all.areas[[k]]
}

eelg.2008.latlon.south.df <- broom::tidy(eelg.2008.latlon.south)

eelg.2008.UTM.south <- spTransform(eelg.2008.latlon.south,
                                   CRS = proj4string(eelg.2008.UTM))

# compute the overlap between UD without land and eelgrass
# the following files were created in HR_analysis_GPS_LC_newtags_2019-10-30.Rmd
pre.daynight <- readRDS(file = "RData/pre_GPS_UD.rds")

# areas are computed using UTM coordinates to keep the same unit - shouldn't make any difference
# but just to be sure.

# compute the eelgrass area
pre.eelgrass.area <- sum(unlist(eelg.2008.all.areas))

# find the intersections with UDs
# extract the land area
area.pre.daynight.95 <- get.area.UTM(pre.daynight$HR$ver.95)
area.pre.daynight.50 <- get.area.UTM(pre.daynight$HR$ver.50)

pre.eelgrass.UD.50 <- rgeos::gIntersection(eelg.2008.UTM.south, 
                                           area.pre.daynight.50)
pre.eelgrass.UD.95 <- rgeos::gIntersection(eelg.2008.UTM.south,
                                           area.pre.daynight.95)

pre.eelgrass.UD.50.latlon <- spTransform(pre.eelgrass.UD.50,
                                         CRS = CRS("+proj=longlat +datum=WGS84"))
pre.eelgrass.UD.95.latlon <- spTransform(pre.eelgrass.UD.95,
                                         CRS = CRS("+proj=longlat +datum=WGS84"))

pre.UD.50.eelg.all.areas <- lapply(pre.eelgrass.UD.50.latlon@polygons[[1]]@Polygons,
                                   FUN = function(x){
                                     areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                       slot(x, "ringDir")
                                   } )
pre.UD.95.eelg.all.areas <- lapply(pre.eelgrass.UD.95.latlon@polygons[[1]]@Polygons,
                                   FUN = function(x){
                                     areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                       slot(x, "ringDir")
                                   } )

# create df for plotting using lat/lon
pre.UD.95.df <- broom::tidy(spTransform(area.pre.daynight.95,
                                        CRS = CRS("+proj=longlat +datum=WGS84")))
pre.UD.50.df <- broom::tidy(spTransform(area.pre.daynight.50,
                                        CRS = CRS("+proj=longlat +datum=WGS84")))


p1 <- ggplot() + 
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = water.color,
               color = "black") + 
  geom_polygon(data = eelg.2008.latlon.south.df,
               aes(x = long, y = lat, group = group),
               fill = eelgrass.color) + 
  geom_polygon(data = pre.UD.95.df,
               aes(x = long, y = lat, group = group),
               fill = pre.95.fill,
               color = pre.95.color,
               alpha = 0.4)  +
  geom_polygon(data = pre.UD.50.df,
               aes(x = long, y = lat, group = group),
               fill = pre.50.fill,
               color = pre.50.color,
               alpha = 0.4)  +
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = "transparent",
               color = "black") +
  labs(x = "", y = "")+ 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = background.color,
                                        colour = water.color),
        #axis.text.x = element_text(angle = 90, vjust = 0.5),
        panel.border = element_rect(color = "black",
                                    fill = NA)) +
  coord_map(xlim = map.west.east,
            ylim = map.north.south)

if (save.fig)
  ggsave(filename = "figures/pre_eelgrass.png",
         device = "png", dpi = 600,
         plot = p1)

p1


```

Post period:
```{r}

eelg.2014.UTM <- readOGR(dsn = "GISfiles/Features",
                         layer = "SD_Baywide_Eelgrass_2014_Final",
                         verbose = F)


eelg.2014.latlon <- spTransform(eelg.2014.UTM,
                                CRS = CRS("+proj=longlat +datum=WGS84"))

eelg.2014.latlon.df <- broom::tidy(eelg.2014.latlon)

# find the south bay eelgrass
eelg.2014.latlon.south <- rgeos::gIntersection(south.bay.box, eelg.2014.latlon)

# recalulate areas of each polygon to make sure they are "correct." 
eelg.2014.all.areas <- lapply(eelg.2014.latlon.south@polygons[[1]]@Polygons,
                    FUN = function(x){
                      areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                        slot(x, "ringDir")
                    } )

for (k in 1:length(eelg.2014.all.areas)){
  slot(eelg.2014.latlon.south@polygons[[1]]@Polygons[[k]], "area") <- eelg.2014.all.areas[[k]]
}

eelg.2014.latlon.south.df <- broom::tidy(eelg.2014.latlon.south)

eelg.2014.UTM.south <- spTransform(eelg.2014.latlon.south,
                                   CRS = proj4string(eelg.2014.UTM))

# compute the overlap between UD without land and eelgrass
# the following files were created in HR_analysis_GPS_LC_newtags_2019-10-30.Rmd
post.daynight <- readRDS(file = "RData/post_GPS_UD.rds")

# extract the land area from UDs
area.post.daynight.95 <- get.area.UTM(post.daynight$HR$ver.95)
area.post.daynight.50 <- get.area.UTM(post.daynight$HR$ver.50)

# create df for plotting using lat/lon
post.UD.95.df <- broom::tidy(spTransform(area.post.daynight.95,
                                         CRS = CRS("+proj=longlat +datum=WGS84")))
post.UD.50.df <- broom::tidy(spTransform(area.post.daynight.50,
                                         CRS = CRS("+proj=longlat +datum=WGS84")))

# areas are computed using UTM coordinates to keep the same unit - shouldn't make any difference
# but just to be sure.
eelg.2014.UTM.south <- spTransform(eelg.2014.latlon.south,
                                   CRS = proj4string(post.daynight$HR$ver.50))

# compute the eelgrass area - make sure area is correct with removed polygons!! 1/8/2020!!
post.eelgrass.area <- sum(unlist(eelg.2014.all.areas))

# find the intersections with UDs
post.eelgrass.UD.50 <- rgeos::gIntersection(eelg.2014.UTM.south, 
                                            area.post.daynight.50)
post.eelgrass.UD.95 <- rgeos::gIntersection(eelg.2014.UTM.south,
                                            area.post.daynight.95)

post.eelgrass.UD.50.latlon <- spTransform(post.eelgrass.UD.50,
                                          CRS = CRS("+proj=longlat +datum=WGS84"))
post.eelgrass.UD.95.latlon <- spTransform(post.eelgrass.UD.95,
                                          CRS = CRS("+proj=longlat +datum=WGS84"))

post.UD.50.eelg.all.areas <- lapply(post.eelgrass.UD.50.latlon@polygons[[1]]@Polygons,
                                    FUN = function(x){
                                      areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                        slot(x, "ringDir")
                                    } )

post.UD.95.eelg.all.areas <- lapply(post.eelgrass.UD.95.latlon@polygons[[1]]@Polygons,
                                    FUN = function(x){
                                      areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                        slot(x, "ringDir")
                                    } )

p1 <- ggplot() + 
   geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = water.color) + 
  geom_polygon(data = eelg.2014.latlon.south.df,
               aes(x = long, y = lat, group = group),
               fill = eelgrass.color) + 
# geom_polygon(data = eelg.2014.latlon.south.2.df,
#                aes(x = long, y = lat, group = group),
#                fill = "red") + 

  # geom_polygon(data = SDBay.df,
  #             aes(x = long, y = lat, group = group)) +
  geom_polygon(data = post.UD.95.df,
               aes(x = long, y = lat, group = group),
               fill = post.95.fill,
               color = post.95.color,
               alpha = 0.4)  +
  geom_polygon(data = post.UD.50.df,
               aes(x = long, y = lat, group = group),
               fill = post.50.fill,
               color = post.50.color,
               alpha = 0.4)  +
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = "transparent",
               color = "black") +
  labs(x = "", y = "")+ 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = background.color,
                                        colour = water.color),
        #axis.text.x = element_text(angle = 90, vjust = 0.5),
        panel.border = element_rect(color = "black",
                                    fill = NA)) +
  coord_map(xlim = map.west.east,
            ylim = map.north.south)

if (save.fig)
ggsave(filename = "figures/post_eelgrass.png",
       device = "png", dpi = 600,
       plot = p1)

p1
```


Pre period just day time
```{r}
pre.day <- readRDS(file = "RData/pre_GPS_UD_day.rds")

# extract the land area from UDs
area.pre.day.95 <- get.area.UTM(pre.day$HR$ver.95)
area.pre.day.50 <- get.area.UTM(pre.day$HR$ver.50)

# create df for plotting using lat/lon
pre.day.UD.95.df <- broom::tidy(spTransform(area.pre.day.95,
                                            CRS = CRS("+proj=longlat +datum=WGS84")))
pre.day.UD.50.df <- broom::tidy(spTransform(area.pre.day.50,
                                            CRS = CRS("+proj=longlat +datum=WGS84")))


# find the intersections with UDs
pre.day.eelgrass.UD.50 <- rgeos::gIntersection(eelg.2008.UTM.south, 
                                               area.pre.day.50)
pre.day.eelgrass.UD.95 <- rgeos::gIntersection(eelg.2008.UTM.south,
                                               area.pre.day.95)

pre.day.eelgrass.UD.50.latlon <- spTransform(pre.day.eelgrass.UD.50,
                                             CRS = CRS("+proj=longlat +datum=WGS84"))
pre.day.eelgrass.UD.95.latlon <- spTransform(pre.day.eelgrass.UD.95,
                                             CRS = CRS("+proj=longlat +datum=WGS84"))

pre.day.UD.50.eelg.all.areas <- lapply(pre.day.eelgrass.UD.50.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

pre.day.UD.95.eelg.all.areas <- lapply(pre.day.eelgrass.UD.95.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

p1 <- ggplot() + 
   geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = water.color) + 
  geom_polygon(data = eelg.2008.latlon.south.df,
               aes(x = long, y = lat, group = group),
               fill = eelgrass.color) + 
# geom_polygon(data = eelg.2014.latlon.south.2.df,
#                aes(x = long, y = lat, group = group),
#                fill = "red") + 

  # geom_polygon(data = SDBay.df,
  #             aes(x = long, y = lat, group = group)) +
  geom_polygon(data = pre.day.UD.95.df,
               aes(x = long, y = lat, group = group),
               fill = pre.95.fill,
               color = pre.95.color,
               alpha = 0.4)  +
  geom_polygon(data = pre.day.UD.50.df,
               aes(x = long, y = lat, group = group),
               fill = pre.50.fill,
               color = pre.50.color,
               alpha = 0.4)  +
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = "transparent",
               color = "black") +
  labs(x = "", y = "")+ 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = background.color,
                                        colour = water.color),
        #axis.text.x = element_text(angle = 90, vjust = 0.5),
        panel.border = element_rect(color = "black",
                                    fill = NA)) +
  coord_map(xlim = map.west.east,
            ylim = map.north.south)

if (save.fig)
  ggsave(filename = "figures/pre_day_eelgrass.png",
         device = "png", dpi = 600,
         plot = p1)

p1
```


Pre period just night time
```{r}
pre.night <- readRDS(file = "RData/pre_GPS_UD_night.rds")

# extract the land area from UDs
area.pre.night.95 <- get.area.UTM(pre.night$HR$ver.95)
area.pre.night.50 <- get.area.UTM(pre.night$HR$ver.50)

# create df for plotting using lat/lon
pre.night.UD.95.df <- broom::tidy(spTransform(area.pre.night.95,
                                            CRS = CRS("+proj=longlat +datum=WGS84")))
pre.night.UD.50.df <- broom::tidy(spTransform(area.pre.night.50,
                                            CRS = CRS("+proj=longlat +datum=WGS84")))

# find the intersections with UDs
pre.night.eelgrass.UD.50 <- rgeos::gIntersection(eelg.2008.UTM.south, 
                                                 area.pre.night.50)
pre.night.eelgrass.UD.95 <- rgeos::gIntersection(eelg.2008.UTM.south,
                                                 area.pre.night.95)

pre.night.eelgrass.UD.50.latlon <- spTransform(pre.night.eelgrass.UD.50,
                                               CRS = CRS("+proj=longlat +datum=WGS84"))
pre.night.eelgrass.UD.95.latlon <- spTransform(pre.night.eelgrass.UD.95,
                                             CRS = CRS("+proj=longlat +datum=WGS84"))

pre.night.UD.50.eelg.all.areas <- lapply(pre.night.eelgrass.UD.50.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

pre.night.UD.95.eelg.all.areas <- lapply(pre.night.eelgrass.UD.95.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

p1 <- ggplot() + 
   geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = water.color) + 
  geom_polygon(data = eelg.2008.latlon.south.df,
               aes(x = long, y = lat, group = group),
               fill = eelgrass.color) + 
# geom_polygon(data = eelg.2014.latlon.south.2.df,
#                aes(x = long, y = lat, group = group),
#                fill = "red") + 

  # geom_polygon(data = SDBay.df,
  #             aes(x = long, y = lat, group = group)) +
  geom_polygon(data = pre.night.UD.95.df,
               aes(x = long, y = lat, group = group),
               fill = pre.95.fill,
               color = pre.95.color,
               alpha = 0.4)  +
  geom_polygon(data = pre.night.UD.50.df,
               aes(x = long, y = lat, group = group),
               fill = pre.50.fill,
               color = pre.50.color,
               alpha = 0.4)  +
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = "transparent",
               color = "black") +
  labs(x = "", y = "")+ 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = background.color,
                                        colour = water.color),
        #axis.text.x = element_text(angle = 90, vjust = 0.5),
        panel.border = element_rect(color = "black",
                                    fill = NA)) +
  coord_map(xlim = map.west.east,
            ylim = map.north.south)

if (save.fig)
  ggsave(filename = "figures/pre_night_eelgrass.png",
         device = "png", dpi = 600,
         plot = p1)

p1
```



Post period just day time
```{r}
post.day <- readRDS(file = "RData/post_GPS_UD_day.rds")

# extract the land area from UDs
area.post.day.95 <- get.area.UTM(post.day$HR$ver.95)
area.post.day.50 <- get.area.UTM(post.day$HR$ver.50)

# create df for plotting using lat/lon
post.day.UD.95.df <- broom::tidy(spTransform(area.post.day.95,
                                            CRS = CRS("+proj=longlat +datum=WGS84")))
post.day.UD.50.df <- broom::tidy(spTransform(area.post.day.50,
                                            CRS = CRS("+proj=longlat +datum=WGS84")))


# find the intersections with UDs
post.day.eelgrass.UD.50 <- rgeos::gIntersection(eelg.2014.UTM.south, 
                                               area.pre.day.50)
post.day.eelgrass.UD.95 <- rgeos::gIntersection(eelg.2014.UTM.south,
                                               area.pre.day.95)

post.day.eelgrass.UD.50.latlon <- spTransform(post.day.eelgrass.UD.50,
                                             CRS = CRS("+proj=longlat +datum=WGS84"))
post.day.eelgrass.UD.95.latlon <- spTransform(post.day.eelgrass.UD.95,
                                             CRS = CRS("+proj=longlat +datum=WGS84"))

post.day.UD.50.eelg.all.areas <- lapply(post.day.eelgrass.UD.50.latlon@polygons[[1]]@Polygons,
                                        FUN = function(x){
                                          areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                            slot(x, "ringDir")
                                        } )

post.day.UD.95.eelg.all.areas <- lapply(post.day.eelgrass.UD.95.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

p1 <- ggplot() + 
   geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = water.color) + 
  geom_polygon(data = eelg.2014.latlon.south.df,
               aes(x = long, y = lat, group = group),
               fill = eelgrass.color) + 
  geom_polygon(data = post.day.UD.95.df,
               aes(x = long, y = lat, group = group),
               fill = post.95.fill,
               color = post.95.color,
               alpha = 0.4)  +
  geom_polygon(data = post.day.UD.50.df,
               aes(x = long, y = lat, group = group),
               fill = post.50.fill,
               color = post.50.color,
               alpha = 0.4)  +
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = "transparent",
               color = "black") +
  labs(x = "", y = "")+ 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = background.color,
                                        colour = water.color),
        #axis.text.x = element_text(angle = 90, vjust = 0.5),
        panel.border = element_rect(color = "black",
                                    fill = NA)) +
  coord_map(xlim = map.west.east,
            ylim = map.north.south)

if (save.fig)
  ggsave(filename = "figures/post_day_eelgrass.png",
         device = "png", dpi = 600,
         plot = p1)

p1
```


Post period just night time
```{r}
post.night <- readRDS(file = "RData/post_GPS_UD_night.rds")

# extract the land area from UDs
area.post.night.95 <- get.area.UTM(post.night$HR$ver.95)
area.post.night.50 <- get.area.UTM(post.night$HR$ver.50)

# create df for plotting using lat/lon
post.night.UD.95.df <- broom::tidy(spTransform(area.post.night.95,
                                               CRS = CRS("+proj=longlat +datum=WGS84")))
post.night.UD.50.df <- broom::tidy(spTransform(area.post.night.50,
                                               CRS = CRS("+proj=longlat +datum=WGS84")))

# find the intersections with UDs
post.night.eelgrass.UD.50 <- rgeos::gIntersection(eelg.2014.UTM.south, 
                                                  area.post.night.50)
post.night.eelgrass.UD.95 <- rgeos::gIntersection(eelg.2014.UTM.south,
                                                  area.post.night.95)

post.night.eelgrass.UD.50.latlon <- spTransform(post.night.eelgrass.UD.50,
                                               CRS = CRS("+proj=longlat +datum=WGS84"))
post.night.eelgrass.UD.95.latlon <- spTransform(post.night.eelgrass.UD.95,
                                             CRS = CRS("+proj=longlat +datum=WGS84"))

post.night.UD.50.eelg.all.areas <- lapply(post.night.eelgrass.UD.50.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

post.night.UD.95.eelg.all.areas <- lapply(post.night.eelgrass.UD.95.latlon@polygons[[1]]@Polygons,
                                       FUN = function(x){
                                         areas <- geosphere::areaPolygon(slot(x, "coords")) * 
                                           slot(x, "ringDir")
                                       } )

p1 <- ggplot() + 
   geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = water.color) + 
  geom_polygon(data = eelg.2014.latlon.south.df,
               aes(x = long, y = lat, group = group),
               fill = eelgrass.color) + 
  geom_polygon(data = post.night.UD.95.df,
               aes(x = long, y = lat, group = group),
               fill = post.95.fill,
               color = post.95.color,
               alpha = 0.4)  +
  geom_polygon(data = post.night.UD.50.df,
               aes(x = long, y = lat, group = group),
               fill = post.50.fill,
               color = post.50.color,
               alpha = 0.4)  +
  geom_polygon(data = SDBay.latlon.df,
               aes(x = long, y = lat, group = group),
               fill = "transparent",
               color = "black") +
  labs(x = "", y = "")+ 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = background.color,
                                        colour = water.color),
        #axis.text.x = element_text(angle = 90, vjust = 0.5),
        panel.border = element_rect(color = "black",
                                    fill = NA)) +
  coord_map(xlim = map.west.east,
            ylim = map.north.south) + 
  ggsn::scalebar(#data = SDBay.latlon.df, 
                 #location = "topright",
                 transform = TRUE,
                 model = "WGS84",
                 dist_unit = "km", 
                 dist = 1,
                 height = 0.1,
                 st.size = 5,
                 st.dist = 0.2,
                 x.min = -117.155,
                 x.max = -117.135,
                 y.min = 32.6,
                 y.max = 32.61) 

if (save.fig)
  ggsave(filename = "figures/post_night_eelgrass.png",
         device = "png", dpi = 600,
         plot = p1)

p1
```

Add all areas for each combination.
```{r}

# pre.daynight.byID <- readRDS(file = "RData/pre_GPS_UD_byID.rds")
# pre.day.byID <- readRDS(file = "RData/pre_GPS_UD_day_byID.rds")
# pre.night.byID <- readRDS(file = "RData/pre_GPS_UD_night_byID.rds")
# post.daynight.byID <- readRDS(file = "RData/post_GPS_UD_byID.rds")
# post.day.byID <- readRDS(file = "RData/post_GPS_UD_day_byID.rds")
# post.night.byID <- readRDS(file = "RData/post_GPS_UD_night_byID.rds")

```


